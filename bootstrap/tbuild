#!/bin/sh
# \
exec "cfkit8.6" "$0" ${1+"$@"}

package require trofs
set top		[trofs::mount [info script]]
set main	[file join $top main.tcl]
if {![file exists $main]} {
	puts stderr "No main.tcl"
	exit 1
}
source $main

if {[catch {
	package require starkit
}]} {
	set have_starkit	0
} else {
	set have_starkit	1
}
package require platform

apply {
	{} {
		set here	[file dirname [info script]]
		foreach platform [platform::patterns [platform::identify]] {
			set pkgpath	[file join $here pkg $platform]
			set tmpath	[file join $here tm $platform]
			if {[file exists $pkgpath] && [file isdirectory $pkgpath]} {
				lappend ::auto_path $pkgpath
			}
			if {[file exists $tmpath] && [file isdirectory $tmpath]} {
				::tcl::tm::path add $tmpath
			}
		}
	}
}

if {$have_starkit && [starkit::startup] eq "sourced"} return

try {
	package require app-[apply {{argv} {return tbuild}} $argv]
} on error {errmsg options} {
	puts stderr "$errmsg\n[dict get $options -errorinfo]"
}
package provide rpm 0.1
package require cflib 1.2
#!/usr/bin/env cfkit8.6

package require cflib 1.2

namespace eval rpm {
	proc run {args} { #<<<
		set cmd	$args
		try {
			lassign [chan pipe] readpipe writepipe
			lappend cmd >@ $writepipe
			set handle	[open |$cmd w]
			chan close $writepipe
			chan configure $handle \
					-blocking 0 \
					-translation binary \
					-encoding binary
			chan configure $handle -blocking 1
			chan close $handle
		} trap {CHILDSTATUS} {errmsg options} {
			set exitstatus	[lindex [dict get $options -errorcode] 2]
			throw [list CHILDSTATUS $exitstatus] $errmsg
		} on ok {} {
			set output	[chan read $readpipe]
			return $output
		} finally {
			if {[info exists readpipe]} {
				if {$readpipe in [chan names]} {
					chan close $readpipe
				}
				unset readpipe
			}
		}
	}

	#>>>
	proc rpm {args} { #<<<
		string trim [run rpm {*}$args]
	}

	#>>>
	proc rpmbuild {args} { #<<<
		string trim [run rpmbuild {*}$args]
	}

	#>>>
	proc build_spec {spec files} { #<<<
		set specdata	""
		append specdata	[subst -novariables -nobackslashes {Name:		[dict get $spec name]
Version:	[dict get $spec version]
Release:	[dict get $spec release]
Source:		[dict get $spec sourcetar]
License:	[dict get $spec license]
Vendor:		[dict get $spec vendor]
Group:		[dict get $spec group]
BuildRoot:	%{_tmppath}/%{name}-%{version}-%{release}-buildroot
}]
		if {[llength [dict get $spec requires]] > 0} {
			append specdata	[subst -novariables -nobackslashes {Requires:	[join [dict get $spec requires] ", "]
}]
		}
		append specdata [subst -novariables -nobackslashes {Summary:	[dict get $spec summary]

%description
[dict get $spec description]

# We need to redefine __os_install_post to prevent it stripping the binaries,
# which breaks for us because it distrupts the appended metakit databases
%define __os_install_post   /usr/lib/rpm/brp-compress; echo "Not stripping"

%prep
%setup -q

%build

%install
rm -rf $RPM_BUILD_ROOT
}]
		dict for {src dst} $files {
			if {[file executable $src]} {
				set mode	"0755"
			} else {
				set mode	"0644"
			}
			append specdata [subst -novariables -nobackslashes {install -d "$RPM_BUILD_ROOT/[string trimleft [file dirname $dst] /]"
install --mode [set mode] "[set src]" "$RPM_BUILD_ROOT/[string trimleft [set dst] /]"
}]
		}	
		append specdata [subst -novariables -nobackslashes {
%clean
rm -rf $RPM_BUILD_ROOT

%post
[dict get $spec post_scriptlet]

%preun
[dict get $spec preun_scriptlet]

%files
}]
		dict for {src dst} $files {
			append specdata $dst "\n"
		}

		return $specdata
	}

	#>>>
	proc make_rpm {spec files {target ""}} { #<<<
		try {
			set sourcedir	[rpm --eval %_sourcedir]
			set specdir		[rpm --eval %_specdir]
			set rpmout		"rpmout"

			set specfile	[file join $specdir testspec.spec]
			set sourcetar	[file join $sourcedir [dict get $spec sourcetar]]

			set specdata	[build_spec $spec $files]

			set fp	[open $specfile w]
			puts $fp $specdata
			close $fp

			set here	[pwd]
			cflib::in_tmp_dir {
				set tarbase	[dict get $spec name]-[dict get $spec version]
				file mkdir $tarbase

				dict for {src dst} $files {
					if {[string index $src 0] eq "/"} {
						set fqsrc	$src
						set src	[string range $src 1 end]
					} else {
						set fqsrc	[file join $here $src]
					}
					set prefix	[file dirname $src]
					set dstdir	[file join $tarbase $prefix]
					if {![file exists $dstdir]} {
						file mkdir $dstdir
					}
					set dsttail	[file tail $src]
					try {
						file copy -- $fqsrc [file join $dstdir $dsttail]
					} on error {errmsg options} {
						puts stderr "Error copying file: $errmsg"
						return -options $options $errmsg
					}
				}
				run tar cvzf $sourcetar $tarbase
			}

			if {[info exists target] && $target ne ""} {
				set buildoutput	[rpmbuild --target $target -bb $specfile 2> /dev/null]
			} else {
				set buildoutput	[rpmbuild -bb $specfile 2> /dev/null]
			}
			foreach line [split $buildoutput \n] {
				if {[string match "Wrote: *" $line]} {
					if {![regexp {^Wrote:\s+(.*)$} $line -> fn]} {
						puts stderr "Couldn't parse output filename from \"$line\""
						continue
					}
					if {![file exists $rpmout]} {
						file mkdir $rpmout
					}
					file copy -force -- $fn $rpmout
					puts "Wrote [file join $rpmout [file tail $fn]]"
					file delete -- $fn
				}
			}
		} finally {
			if {[info exists specfile] && [file exists $specfile]} {
				file delete -- $specfile
			}
			if {[info exists sourcetar] && [file exists $sourcetar]} {
				file delete -- $sourcetar
			}
		}
	}

	#>>>
}

# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4
package provide cflib 1.2

		namespace eval cflib {}
	
# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4

proc cflib::readfile {fn {mode text}} {
	try {
		set fp	[open $fn r]
		if {$mode eq "binary"} {
			chan configure $fp \
					-translation binary \
					-encoding binary
		}
		set dat	[read $fp]

		return $dat
	} finally {
		if {[info exists fp] && $fp in [chan names]} {
			close $fp
		}
	}
}


# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4

oo::class create cflib::pclass {
	superclass oo::class

	constructor {def} { #<<<
		my variable superclass_seen
		my pclass_config {}		;# ensure defaults are set

		set superclass_seen	0

		foreach m {
			superclass
			property
			protected_property
			constructor
			method
			destructor
			pclass_config
		} {
			interp alias {} [self namespace]::$m {} [self] $m
		}
		foreach m {
			mixin
			filter
			unexport
			export
			variable
		} {
			interp alias {} [self namespace]::$m {} oo::define [self] $m
		}

		my eval $def

		if {!($superclass_seen)} {
			if {[self] ne "::cflib::pclassbase"} {
				#puts stderr "[self] forcing superclass cflib::pclassbase"
				oo::define [self] superclass cflib::pclassbase
			}
		}
	}

	#>>>
	method _get_prop_var {} { #<<<
		set othervar	[self]::_props
		if {![namespace exists [self]]} {
			namespace eval [self] {}
		}
		return $othervar
	}

	#>>>
	method _provides_baseclass {baseclass class} { #<<<
		if {$class eq $baseclass} {return 1}
		foreach superclass [info class superclasses $class] {
			if {[my _provides_baseclass $baseclass $superclass]} {
				return 1
			}
		}
		return 0
	}

	#>>>
	method superclass {args} { #<<<
		my variable superclass_seen
		set superclass_seen	1
		set seenhere	0
		set baseclass	"cflib::pclassbase"
		foreach superclass $args {
			if {[my _provides_baseclass $baseclass $superclass]} {
				set seenhere	1
				break
			}
		}
		if {!($seenhere)} {
			set args	[concat [list $baseclass] $args]
			#lappend args $baseclass
		}
		#puts stderr "[self] spliced in superclass cflib::pclassbase: ($args)"
		oo::define [self] superclass {*}$args
	}

	#>>>
	method property {name args} { #<<<
		lassign $args initval change_handler
		set othervar	[my _get_prop_var]
		#puts "setting property $name on [self] ($othervar)"
		dict set $othervar $name	[dict create protection public]
		if {[llength $args] >= 1} {
			dict set $othervar $name initval $initval
		}
		if {[llength $args] >= 2} {
			dict set $othervar $name change_handler $change_handler
		}
	}

	#>>>
	method protected_property {name args} { #<<<
		lassign $args initval change_handler
		set othervar	[my _get_prop_var]
		dict set $othervar $name	[dict create protection protected]
		if {[llength $args] >= 1} {
			dict set $othervar $name initval $initval
		}
		if {[llength $args] >= 2} {
			dict set $othervar $name change_handler $change_handler
		}
	}

	#>>>
	method constructor {args body} { #<<<
		my variable cfg
		set othervar	[my _get_prop_var]
		upvar $othervar props

		set newbody {}
		if {[dict get $cfg constructor_auto_next]} {
			append newbody {
				if {[self next] ne {}} {next}
			}
		}
		append newbody {
			if {[info exists [my varname _props]]} {
				dict for {k inf} [set [my varname _props]] {
					my variable $k
				}
				if {[info exists k]} {unset k}
				if {[info exists inf]} {unset inf}
			}
		}
		append newbody $body

		oo::define [self] constructor $args $newbody
	}

	#>>>
	method method {name args body} { #<<<
		set newbody	{
			if {[info exists [my varname _props]]} {
				dict for {k inf} [set [my varname _props]] {
					my variable $k
				}
				if {[info exists k]} {unset k}
				if {[info exists inf]} {unset inf}
			}
		}
		append newbody $body
		oo::define [self] method $name $args $newbody
	}

	#>>>
	method destructor {body} { #<<<
		set newbody	{
			if {[info exists [my varname _props]]} {
				dict for {k inf} [set [my varname _props]] {
					my variable $k
				}
				if {[info exists k]} {unset k}
				if {[info exists inf]} {unset inf}
			}
		}
		append newbody $body {
			if {[self next] ne {}} {next}
		}
		oo::define [self] destructor $newbody
	}

	#>>>
	method pclass_config {config} { #<<<
		my variable cfg
		if {![info exists cfg]} {
			set cfg	{}
		}
		set cfg [dict merge {
			constructor_auto_next	1
		} $cfg $config]
	}

	#>>>
}


cflib::pclass create cflib::pclassbase {
	constructor {} { #<<<
		#puts "in cflib::pclassbase::constructor for [self]"
		my variable _props
		if {![info exists _props]} {
			#puts "initalizing _props"
			set _props	[dict create]
		}
		my _mixin_props	[info object class [self]]
		if {[info exists [my varname _props]]} {
			dict for {k inf} [set [my varname _props]] {
				my variable $k
				if {[dict exists $inf initval]} {
					set $k [dict get $inf initval]
				}
			}
			if {[info exists k]} {unset k}
			if {[info exists inf]} {unset inf}
		}
	}

	#>>>
	method cget {name args} { #<<<
		if {[llength $args] > 1} {
			error "Too many arguments, expecting name ?default_value?"
		}
		my variable _props
		if {[dict exists $_props $name] && [dict get $_props $name protection] eq "public"} {
			my variable $name
			if {[info exists $name]} {
				return [set $name]
			} elseif {[llength $args] > 0} {
				return [lindex $args 0
			}
		} else {
			error "Invalid property \"$name\""
		}
	}

	#>>>
	method configure {args} { #<<<
		if {[llength $args] == 0} return
		my variable _props
		if {![info exists _props]} {
			error "Can't run configure on [self]: _props ([my varname _props]) is missing"
		}
		dict for {k v} $args {
			if {[string index $k 0] ne "-"} {
				throw {SYNTAX GENERAL} "Invalid property name \"$k\""
			}
			set k	[string range $k 1 end]
			if {![dict exists $_props $k]} {
				throw [list SYNTAX PROPERTY_NOTDEFINED -$k] \
						"Invalid property: \"$k\", expecting one of \"[join [dict keys $_props] \",\ \"]\""
			}
			if {[dict get $_props $k protection] ne "public"} {
				throw [list PROTECTION $k] "Property \"$k\" is not public"
			}
			set fqvar	[self namespace]::$k
			if {[info exists $fqvar]} {
				set oldval	[set $fqvar]
			}
			set $fqvar	$v
			if {[dict exists $_props $k change_handler]} {
				try {
					namespace inscope [self namespace] [list my [dict get $_props $k change_handler]]
				} trap {PROPERTY ABORT_CHANGE} {} {
					if {[info exists oldval]} {
						set $fqvar	$oldval
					}
				} on error {errmsg options} {
					if {[info exists oldval]} {
						set $fqvar	$oldval
					}
					dict incr options -level
					return -options $options $errmsg
				}
			}
		}
	}

	#>>>
	method _mixin_props {fromclass} { #<<<
		#puts "_mixin_props on [self], merging ($fromclass)"
		my variable _props
		if {![info exists _props]} {
			set _props	[dict create]
		}
		if {[info exists ${fromclass}::_props]} {
			dict for {k v} [set ${fromclass}::_props] {
				if {![dict exists $_props $k]} {
					dict set _props $k $v
				}
			}
		}
		set superclasses	[info class superclasses $fromclass]
		foreach superclass $superclasses {
			my _mixin_props $superclass
		}
	}

	#>>>

	# convenience methods
	method code {args} { #<<<
		return [namespace code [list my {*}$args]]
	}
	unexport code

	#>>>
}

proc cflib::intersect3 {list1 list2} {
	set firstonly       {}
	set intersection    {}
	set secondonly      {}

	set list1	[lsort -unique $list1]
	set list2	[lsort -unique $list2]

	foreach item $list1 {
		if {[lsearch -sorted $list2 $item] == -1} {
			lappend firstonly $item
		} else {
			lappend intersection $item
		}
	}

	foreach item $list2 {
		if {[lsearch -sorted $intersection $item] == -1} {
			lappend secondonly $item
		}
	}


	return [list $firstonly $intersection $secondonly]
}


# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4

proc cflib::writefile {fn data {mode "text"}} {
	try {
		set fp	[open $fn w]
		if {$mode eq "binary"} {
			chan configure $fp \
					-translation binary \
					-encoding binary
		}
		chan puts -nonewline $fp $data
	} finally {
		if {[info exists fp] && $fp in [chan names]} {
			close $fp
		}
	}
}


# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> foldmarker=<<<,>>>

oo::class create cflib::baselog {
	method log {lvl {msg ""} args} {
		puts "$msg"
		#uplevel [string map [list %lvl% $lvl %msg% $msg %args% $args] {
		#	puts "[self] [self class]::[self method] %lvl% %msg%"
		#}]
	}
}


# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4

oo::class create cflib::config {
	variable {*}{
		definitions
		cfg
		rest
	}

	constructor {argv config} { #<<<
		package require dsl
		set cfg	[dict create]

		set slave	[interp create -safe]
		try {
			dsl::dsl_eval $slave {
				variable {definitionsvar varname default} { #<<<
					dict set $definitionsvar $varname default $default
				}

				#>>>
			} $config [namespace which -variable definitions]
		} finally {
			if {[interp exists $slave]} {
				interp delete $slave
			}
		}

		set mode	"key"
		set rest	{}
		foreach arg $argv {
			switch -- $mode {
				key {
					if {[string index $arg 0] eq "-"} {
						set key	[string range $arg 1 end]
						if {![dict exists $definitions $key]} {
							throw [list bad_config_setting $key] \
									"Invalid config setting: \"$key\""
						}
						set mode	"val"
					} else {
						lappend rest	$arg
					}
				}

				val {
					dict set cfg $key $arg
					set mode	"key"
				}
			}
		}

		dict for {k v} $definitions {
			if {![dict exists $cfg $k]} {
				dict set cfg $k [dict get $definitions $k default]
			}
		}
	}

	#>>>
	method get {key args} { #<<<
		switch -- [llength $args] {
			0 {
				if {![dict exists $cfg $key]} {
					throw [list bad_config_setting $key] \
							"Invalid config setting: \"$key\""
				}
				return [dict get $cfg $key]
			}

			1 {
				if {[dict exists $cfg $key]} {
					return [dict get $cfg $key]
				} else {
					return [lindex $args 0]
				}
			}

			default {
				error "Too many arguments: expecting key ?default?"
			}
		}
	}

	#>>>
	method rest {} { #<<<
		return $rest
	}

	#>>>
}
# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4

proc cflib::in_tmp_dir {script} { #<<<
	set oldpwd	[pwd]
	set tempfp	[file tempfile tmpdir]
	close $tempfp
	file delete $tmpdir
	file mkdir $tmpdir
	cd $tmpdir
	try {
		uplevel $script
	} on error {errmsg options} {
		dict incr options -level
		return -options $options $errmsg
	} on ok {res} {
		return $res
	} finally {
		cd $oldpwd
		if {[info exists tmpdir] && [file exists $tmpdir]} {
			# TODO: paranoid checks
			file delete -force -- $tmpdir
		}
	}
}

#>>>
# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4

oo::class create cflib::handlers {
	variable {*}{
		allow_unregistered
		handlers
		afterids
		processing_handlers
		processing_stack
	}

	constructor {} { #<<<
		set allow_unregistered	1
		set handlers			[dict create]
		set afterids			[dict create]
		set processing_handlers	0
		set processing_stack	{}
	}

	#>>>
	destructor { #<<<
		if {[info exists afterids]} {
			dict for {key val} $afterids {
				after cancel $val
				dict unset afterids $key
			}
		}
		if {[self next] ne {}} {next}
	}

	#>>>

	method register_handler {type handler} { #<<<
		if {
			![dict exists $handlers $type]
			|| $handler ni [dict get $handlers $type]
		} {
			my _handlers_debug trivia "Registering handler ($type) ($handler)"
			dict lappend handlers $type	$handler
		}
	}

	#>>>
	method deregister_handler {type handler} { #<<<
		if {![dict exists $handlers $type]} return
		set idx	[lsearch [dict get $handlers $type] $handler]
		#my log trivia "[self] Deregistering handler ($type) ($handler)"
		dict set handlers $type	[lreplace [dict get $handlers $type] $idx $idx]
	}

	#>>>
	method handlers_available {type} { #<<<
		return [expr {
			[dict exists $handlers $type] &&
			[llength [dict get $handlers $type]] >= 1}]
	}

	#>>>
	method dump_handlers {} { #<<<
		return $handlers
	}

	#>>>

	method invoke_handlers {type args} { #<<<
		if {![dict exists $handlers $type]} {
			if {$allow_unregistered} {
				return
			} else {
				error "[self]: No handlers found for type: ($type)"
			}
		}

		set results	{}
		if {$processing_handlers} {
			my _handlers_debug debug "detected reentrant handling for ($type) stack: ($processing_stack)"
		}
		incr processing_handlers	1
		lappend processing_stack	$type
		set last_handler	""
		try {
			my _handlers_debug debug "entering processing of $type"
			foreach handler [dict get $handlers $type] {
				# Check if a previous handler removed this one <<<
				if {
					![dict exists $handlers $type] ||
					$handler ni [dict get $handlers $type]
				} {
					my _handlers_debug debug "Skipping handler ($handler) which has just been removed (presumably by a previous handler in the list"
					continue
				}
				# Check if a previous handler removed this one >>>
				set pending_afterid	\
						[after 3000 [namespace code [list my _throw_hissy_handler $handler $args]]]
				set last_handler	$handler
				dict set afterids invoke_handler_$handler)	$pending_afterid
				my _handlers_debug debug "Invoking callback for ($type): ($handler)"
				lappend results	[uplevel #0 $handler $args]
				after cancel $pending_afterid
				dict unset afterids	invoke_handler_$handler
			}
		} on ok {} {
			incr processing_handlers	-1
			set processing_stack		[lrange $processing_stack 0 end-1]
			my _handlers_debug debug "leaving processing of $type"
			return $results
		} on error {errmsg options} {
			incr processing_handlers	-1
			set processing_stack		[lrange $processing_stack 0 end-1]
			my _handlers_debug error "\nError processing handlers for ($type), in handler ($last_handler): $errmsg\n[dict get $options -errorinfo]"
			dict incr options -level
			return -options $options $errmsg
		}
	}

	#>>>
	method _debug {msg} { #<<<
		my _handlers_debug debug $msg
	}

	#>>>
	method _handlers_debug {lvl msg} { #<<<
		# Override in derived class
		switch -- $lvl {
			warning -
			error {
				puts stderr "cflib::handlers::handlers_debug([self]): $lvl $msg"
			}
		}
	}

	#>>>

	method _throw_hissy_handler {handler arglist} { #<<<
		puts stderr "\n\nHandlers::throw_hissy: obj: ([self]) taking way too long to complete invoke_handlers for handler: ($handler)\n\targs: ($arglist)\n\n"
	}

	#>>>
}


# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4

proc cflib::fullynormalize {fn} {
	set fqfn	[file normalize $fn]

	set patience	20
	set seen		{}
	while {[file type $fqfn] eq "link"} {
		set fqfn	[file normalize [file readlink $fqfn]]
		if {[incr patience -1] <= 0} {
			error "Too many symlinks: $fn"
		}
		if {$fqfn in $seen} {
			error "Circular symlinks: $fn"
		}
	}

	return $fqfn
}


# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4

oo::class create cflib::refcounted {
	constructor {} {
		if {[self next] ne {}} {next}
		set refcount	1
	}

	destructor {
		my _clear_registry
		if {[self next] ne {}} {next}
	}

	variable {*}{
		refcount
		registry_var
	}

	method object_registry {varname} { #<<<
		my _clear_registry

		set registry_var	$varname
		upvar $registry_var var_ref

		set var_ref		[self]
	}

	#>>>
	method incref {args} { #<<<
		set old		$refcount
		incr refcount
		my log_cmd debug "[self]: refcount $old -> $refcount ($args)"
	}

	#>>>
	method decref {args} { #<<<
		set old		$refcount
		incr refcount -1
		my log_cmd debug "[self]: refcount $old -> $refcount ($args)"
		if {$refcount <= 0} {
			my log_cmd debug "[self]: our time has come"
			my destroy
			return
		}
	}

	#>>>
	method refcount {} { #<<<
		return $refcount
	}

	#>>>

	method log_cmd {lvl msg args} {}
	method autoscoperef {} { #<<<
		my log_cmd debug "[self class]::[self method] callstack: (callstack dump broken)"
		upvar 2 _cflib_refcounted_scoperef_[string map {:: //} [self]] scopevar
		set scopevar	[self]
		trace variable scopevar u [namespace code {my decref "scopevar unset"}]
	}

	#>>>
	method _clear_registry {} { #<<<
		if {[info exists registry_var]} {
			upvar $registry_var old_registry
			if {[info exists old_registry]} {
				unset old_registry
			}
		}
	}

	#>>>
}


package provide sugar 0.1
# Sugar - a macro system for Tcl
# Copyright (C) 2004 Salvatore Sanfilippo
# Under the same license as Tcl version 8.4

### Changes
#
# 25Mar2004 - Added support for unique identifiers (sugar::uniqueName).
# 25Mar2004 - Now macros can specify a list of arguments instead of
#             a unique argument that will receive a list. For old behaviour
#             just use 'args'.
# 24Mar2004 - Modified the tailcal_proc transformer to use [foreach] for
#             multiple assignments instead to create temp vars. Thanks
#             to Richard Suchenwirth for the suggestion.

### TODO
#
# - better macro error reporting (line numbers).
# - call the macro system recursively for variable expansions?
#   this allows to expand syntax that have to deal with
#   variables interpolated inside other strings. (probably not).
# - Write a better macro for [switch] using sugar::scriptToList.
# - Write a macro that convert a subset of Tcl to critcl.
# - sugar::interleaveSpace should remove spaces before the first
#   element of type TOK from the original parsed command.
#   This is not needed for simple macro expansion because the
#   sugar::expand function does this automatically, but it's needed
#   when playing raw with the output of sugar::scriptToList.
# - Investigate on indentation changes with the tailrec macro
#   (DONE: Fixed thanks to another related bug found by NEM).
# - An API to provide unique variable names for macro expansions.


namespace eval sugar {}
namespace eval sugar::macro {}
namespace eval sugar::syntaxmacro {}
namespace eval sugar::transformermacro {}

# An incremental id used to create unique identifiers.
set sugar::unique_id 0

# This global variable contains the name of the procedure being
# expanded.
set sugar::currentprocedure {}

# Return the fully-qualified name of the current procedure.
proc sugar::currentProcName {} {
    return $sugar::currentprocedure
}

# Return the "tail" of the current procedure name.
proc sugar::currentProcTail {} {
    namespace tail $sugar::currentprocedure
}

# Return the namespace of the current procedure name.
proc sugar::currentProcNamespace {} {
    namespace qualifiers $sugar::currentprocedure
}

# Return an unique identifier that macros can use as variable/proc names.
proc sugar::uniqueName {} {
    set id [incr sugar::unique_id]
    return __sugarUniqueName__$id
}

# Initialize the state of the interpreter.
# Currently this parser is mostly stateless, it only needs
# to save the type of the last returned token to know
# if something starting with '#' is a comment or not.
proc sugar::parserInitState statevar {
    upvar $statevar state
    set state [list EOL]
}

# The parser. It does not discard info about space and comments.
# The return value is the "type" of the token (EOF EOL SPACE TOKEN).
#
# It may be interesting to note that this is half of a simple
# Tcl interpreter. variable expansions is ignored, while command
# expansion is performed expanding macros if needed.
#
# The fact that it is still so simple, compared to what it can
# be in Python just to say one (much worst in Perl), it's an advice
# that to add syntax to Tcl is a bad idea.
proc sugar::parser {text tokenvar indexvar statevar {dosubst 0}} {
    upvar $tokenvar token $indexvar i $statevar state
    set token {}
    set inside {}
    set dontstop $dosubst
    while 1 {
	# skip spaces
	while {!$dontstop && [string match "\[ \t\]" [string index $text $i]]} {
	    append token [string index $text $i]
	    incr i
	}
	# skip comments
	if {$state eq {EOL} && !$dontstop && [string equal [string index $text $i] #]} {
	    while {[string length [string index $text $i]] &&
	          ![string match [string index $text $i] \n]} \
	    {
		append token [string index $text $i]
		incr i
	    }
	}
	# return a SPACE token if needed
	if {[string length $token]} {return [set state SPACE]}
	# check for special conditions
	if {!$dontstop} {
	    switch -exact -- [string index $text $i] {
		{} {return [set state EOF]}
		{;} -
		"\n" {
		    append token [string index $text $i]
		    incr i
		    return [set state EOL]
		}
	    }
	}
	# main parser loop
	while 1 {
	    switch -exact -- [string index $text $i] {
		{} break
		{ } -
		"\t" -
		"\n" -
		";" {
		    if {!$dontstop} {
			break;
		    }
		}
		\\ {
		    incr i
		    append token \\ [string index $text $i]
		    incr i
		    continue
		}
		\" {
		    if {[string equal $inside {}]} {
			incr dontstop
			set inside \"
			append token \"
			incr i
			continue
		    } elseif {[string equal $inside \"]} {
			incr dontstop -1
			set inside {}
			append token \"
			incr i
			continue
		    }
		}
		"\{" {
		    if {[string equal $inside {}]} {
			incr dontstop
			set inside "\{"
			append token "\{"
			incr i
			continue
		    } elseif {[string equal $inside "\{"]} {
			incr dontstop
		    }
		}
		"\}" {
		    if {[string equal $inside "\{"]} {
			incr dontstop -1
			if {$dontstop == 0} {
			    set inside {}
			    append token "\}"
			    incr i
			    continue
			}
		    }
		}
		\$ {
		    if {![string equal $inside "\{"]} {
			if {![string equal [string index $text [expr {$i+1}]] $]} {
			    set res [LctSubstVar $text i]
			    append token "$$res"
			    continue
			}
		    }
		}
		\[ {
		    if {![string equal $inside "\{"]} {
			set res [LctSubstCmd $text i]
			append token "\[$res\]"
			continue
		    }
		}
	    }
	    append token [string index $text $i]
	    incr i
	}
	return [set state TOK]
    }
}

# Actually does not really substitute commands, but
# exapands macros inside.
proc LctSubstCmd {text indexvar} {
    upvar $indexvar i
    set go 1
    set cmd {}
    incr i
    while {$go} {
	switch -exact -- [string index $text $i] {
	    {} break
	    \[ {incr go}
	    \] {incr go -1}
	}
	append cmd [string index $text $i]
	incr i
    }
    set cmd [string range $cmd 0 end-1]
    return [::sugar::expand $cmd]
}

# Get the control when a '$' (not followed by $) is encountered,
# extract the name of the variable, and return it.
proc LctSubstVar {text indexvar} {
    upvar $indexvar i
    set dontstop 0
    set varname {}
    incr i
    while {1} {
	switch -exact -- [string index $text $i] {
	    \[ -
	    \] -
	    "\t" -
	    "\n" -
	    "\"" -
	    \; -
	    \{ -
	    \} -
	    \$ -
	    ( -
	    ) -
	    { } -
	    "\\" -
	    {} {
		if {!$dontstop} {
		    break
		}
	    }
	    ( {incr dontstop}
	    ) {incr dontstop -1}
	    default {
		append varname [string index $text $i]
	    }
	}
	incr i
    }
    return $varname
}

# Return the number of lines in a string
proc countlines {string} {
    llength [split $string "\n"]
}

# interleave SPACE and EOL tokens in a Tcl list $tokens
# representing a command. Also every token is
# converted to the two-elements list representation
# with type TOK.
#
# The $origargv list is the output of the parser
# for that command, and is used by interleaveSpaces
# to make the indentation of the expanded macro as
# similar as possible to what the used typed in the source
# code.
proc sugar::interleaveSpaces {tokens origargv} {
    set newargv {}
    for {set j 0} {$j < [llength $tokens]} {incr j} {
	lappend newargv [list TOK [lindex $tokens $j]]
	set idx [::sugar::indexbytype $origargv SPACE $j]
	if {$idx == -1} {
	    lappend newargv [list SPACE " "]
	} else {
	    # If possible, try to use the same argument
	    # separator as the user typed it.
	    lappend newargv [lindex $origargv $idx]
	}
    }
    # Use the same EOL string. That's always possible
    if {![llength $newargv]} {
	set newargv [list ";"]
    }
    lset newargv end [lindex $origargv end]
    return $newargv
}

# Tranform a script to a list of lists, where every list is
# a command, and every element of the list is an argument,
# and is itself a two elements of list. The first element
# is the token type, the second the toke value. The following
# toke types are defined.
#
# SPACE - Spaces, non significative for the execution, just separate arguments.
# TOK   - Any significative token. The first element of type TOK is
#         the command name.
# EOL   - End of line.
#
# This function is intended to be used directly or indirectly by macro,
# that will do the processing, and then call listToScript to convert
# it back in script.
#
# Macros may want to call sugar::tokens for every command to work
# more comfortably with it, and than reconvert to the
# original format with sugar::interleaveSpaces.
#
# ----------------------------------------------------------------------
# In theory sugar::expand should be modified to directly use this
# instead of a local copy of almost the same code. They are actually
# a bit different because sugar::expand does the processing for every
# command, not in the entire script at once.
proc sugar::scriptToList script {
    set i 0
    set result {}
    ::sugar::parserInitState parserState

    set eof 0
    while 1 {
	set command {}
	while 1 {
	    set type [::sugar::parser $script token i parserState]
	    switch $type {
		EOF {lappend command [list EOL {}]; set eof 1; break}
		default {
		    lappend command [list $type $token]
		    if {$type eq {EOL}} break
		}
	    }
	}
	lappend result $command
	if {$eof} break
    }
    return $result
}

# That's really trivial ;)
# The macro specification should guarantee that the list
# is transformed into the source code by simple concatenation
# of all the tokens.
proc sugar::listToScript list {
    set result {}
    foreach c $list {
	foreach t $c {
	    append result [lindex $t 1]
	}
    }
    return $result
}

# Return true if the named macro exists, and store in macroName var
# the fully qualified name of the procedure in charge to do expansion for it.
proc sugar::lookupMacro {macroname procnameVar} {
    upvar 1 $procnameVar procname
    if {[catch {info args ::sugar::macro::__macroproc__$macroname}]} {
	return 0
    }
    set procname ::sugar::macro::__macroproc__$macroname
    return 1
}

# Macro expansion. It trys to take indentation unmodified.
proc sugar::expand script {
    while 1 {
	set eof 0
	set i 0
	set result {}
	::sugar::parserInitState parserState
	while {!$eof} {
	    set argv {}
	    set argc 0
	    # Collect a command in $argv. Every token is a two-elements
	    # List with the token type and value, as returned by expr.
	    # Significative tokens are interleaved with space tokens:
	    # syntax  macros will have a way to know how arguments where
	    # separated.
	    while 1 {
		set type [::sugar::parser $script token i parserState]
		if {[string equal $type EOF]} {
		    set eof 1
		}
		switch $type {
		    EOF {lappend argv [list EOL {}]; break}
		    default {
			if {$type eq {SPACE} && $argc == 0} {
			    append result $token
			} else {
			    lappend argv [list $type $token]
			    incr argc
			    if {$type eq {EOL}} break
			}
		    }
		}
	    }
	    # Call macros for this statement
	    if {[lindex $argv 0 0] ne {EOL}} {
		# Check if there is a macro defined with that name
		set cmdname [lindex $argv 0 1]
		# Call the macro associated with that command name, if any.
		if {[sugar::lookupMacro $cmdname expander]} {
		    #puts "executing macro for $cmdname in procedure [::sugar::currentProcName]"
		    if {[catch {set tokens [eval $expander [::sugar::tokens $argv]]} errstr]} {
			error "Macro '$cmdname' expansion error in procedure '$::sugar::currentprocedure': $errstr" $::errorInfo
		    }
		    set argv [::sugar::interleaveSpaces $tokens $argv]
		}
		# Call all the syntax macros. For now in random order.
		foreach syntaxmacro [info command ::sugar::syntaxmacro::__macroproc__*] {
		    set argv [::sugar::interleaveSpaces [eval $syntaxmacro [::sugar::tokens $argv]] $argv]
		}
	    }
	    foreach arg $argv {
		append result "[lindex $arg 1]"
	    }
	}
	# Call all the transformer macros. For now in random order.
	# TODO: consider if it's better to move this as first
	# transformation.
	foreach trmacro [info command ::sugar::transformermacro::__macroproc__*] {
	    set list [::sugar::scriptToList $result]
	    set list [$trmacro $list]
	    set result [::sugar::listToScript $list]
	}
	# Reiterate if needed, otherwise exit.
	if {[string equal $script $result]} break
	#puts "AFTER:  '$script'"
	#puts "BEFORE: '$result'"
	#puts "---"
	set script $result
    }
    return $result
}

# Return the index of the $num-Th element of type $type in a list
# of tokens.
proc ::sugar::indexbytype {argv type num} {
    set idx 0
    foreach a $argv {
	foreach {t _} $a break
	if {$type eq $t} {
	    if {!$num} {
		return $idx
	    }
	    incr num -1
	}
	incr idx
    }
    return -1
}

# Wrapper for [proc] that expands macro in the body
# TODO: add a switch -nomacro to avoid macro expansion
# for the given procedure.
proc sugar::proc {name arglist body} {
    # Get the fully qualified name of the proc
    set ns [uplevel [list namespace current]]
    # If the proc call did not happen at the global context and it did not
    # have an absolute namespace qualifier, we have to prepend the current
    # namespace to the command name
    if { ![string equal $ns "::"] } {
	if { ![string match "::*" $name] } {
	    set name "${ns}::${name}"
	}
    }
    if { ![string match "::*" $name] } {
	set name "::$name"
    }

    set oldprocedure $::sugar::currentprocedure
    set ::sugar::currentprocedure $name
    # puts "+ $name"
    set body [::sugar::expand $body]
    # Call the real [proc] command.
    uplevel 1 [list ::proc $name $arglist $body]
    set ::sugar::currentprocedure $oldprocedure
    return
}

# Number of tokens of type TOK. Useful for arity checking in macros.
proc sugar::tokensnum argv {
    set c 0
    foreach a $argv {
	if {[lindex $a 0] eq {TOK}} {
	    incr c
	}
    }
    return $c
}

# Return values of all the tokens of type TOK as a list.
proc sugar::tokens argv {
    set tokens {}
    foreach a $argv {
	if {[lindex $a 0] eq {TOK}} {
	    lappend tokens [lindex $a 1]
	}
    }
    return $tokens
}

# Define a new macro
proc sugar::macro {names arglist body} {
    foreach name $names {
	uplevel 1 [list ::proc ::sugar::macro::__macroproc__$name $arglist $body]
    }
}

# Define a new syntax macro
proc sugar::syntaxmacro {name arglist body} {
    uplevel 1 [list ::proc ::sugar::syntaxmacro::__macroproc__$name $arglist $body]
}

# Define a new transformer macro
proc sugar::transformermacro {name arglist body} {
    uplevel 1 [list ::proc ::sugar::transformermacro::__macroproc__$name $arglist $body]
}

# That's used to create macros that expands arguments that are
# scripts. This kind of macros are used for [while], [for], [if],
# and so on.
proc sugar::expandScriptToken tok {
    set t [lindex $tok 0]
    set res [::sugar::expand $t]
    if {[string equal $t $res]} {
	return $tok
    } else {
	list $res
    }
}

# Macro substitution. Like [subst] but for macros.
proc sugar::dosubst string {
    sugar::parserInitState state
    set idx 0
    sugar::parser $string result idx state 1
    return $result
}

# Expand Expr's expressions. Try to don't mess with quoting.
proc sugar::expandExprToken tok {
    set quoted 0
    if {[string index $tok 0] == "\{" && [string index $tok end] == "\}"} {
	set quoted 1
	set tok [string range $tok 1 end-1]
    }
    set tok [sugar::dosubst $tok]
    if {$quoted} {
	set tok "{$tok}"
    }
    return $tok
}

# Get the N-th element with type $type from the list of tokens.
proc sugar::gettoken {argv type n} {
    set idx [::sugar::indexbytype $argv $type $n]
    if {$idx == -1} {
	error "bad index for gettoken (wrong number of args for macro?)"
    }
    lindex $argv $idx 1
}

# Set the N-th $type element in the list of tokens to the new $value.
proc sugar::settoken {argvVar type n value} {
    upvar $argvVar argv
    set idx [::sugar::indexbytype $argv $type $n]
    if {$idx == -1} {
	error "bad index for gettoken (wrong number of args for macro?)"
    }
    lset argv $idx 1 $value
}

################################################################################
# Macros to allow macros inside conditionals, loops and other Tcl commands
# that accept scripts or [expr] expressions as arguments.
################################################################################

sugar::macro while args {
    lset args 1 [sugar::expandExprToken [lindex $args 1]]
    lset args 2 [sugar::expandScriptToken [lindex $args 2]]
}

sugar::macro foreach args {
    lset args end [sugar::expandScriptToken [lindex $args end]]
}

sugar::macro time args {
    lset args 1 [sugar::expandScriptToken [lindex $args 1]]
}

sugar::macro if args {
    lappend newargs [lindex $args 0]
    lappend newargs [sugar::expandExprToken [lindex $args 1]]
    set args [lrange $args 2 end]
    foreach a $args {
	switch -- $a {
	    else - elseif {
		lappend newargs $a
	    }
	    default {
		lappend newargs [sugar::expandScriptToken $a]
	    }
	}
    }
    return $newargs
}

sugar::macro for args {
    lset args 1 [sugar::expandScriptToken [lindex $args 1]]
    lset args 3 [sugar::expandScriptToken [lindex $args 3]]
    lset args 4 [sugar::expandScriptToken [lindex $args 4]]
    return $args
}

# That's still not perfect because messes with indentation.
# Should use new scriptToList API to do it better.
sugar::macro switch args {
    lappend result [lindex $args 0]
    set idx 0
    set isquoted 0
    while 1 {
	incr idx
	set arg [lindex $args $idx]
	if {$arg eq {--}} {
	    lappend result $arg
	    incr idx
	    break
	}
	if {[string index $arg 0] ne {-}} break
	lappend result $arg
    }
    lappend result [lindex $args $idx]
    incr idx
    # Handle the two forms in two different ways
    if {[llength $args]-$idx == 1} {
	set l [lindex $args $idx 0]
	set isquoted 1
    } else {
	set l [lrange $args $idx end]
    }
    # Expand scripts inside
    set temp {}
    foreach {pattern body} $l {
	if {$body ne {-}} {
	    if {$isquoted} {
		set body [lindex [sugar::expandScriptToken [list $body]] 0]
	    } else {
		set body [sugar::expandScriptToken $body]
	    }
	}
	lappend temp $pattern $body
    }
    # Requote it if needed.
    if {$isquoted} {
	return [concat $result [list [list $temp]]]
    } else {
	return [concat $result $temp]
    }
}

################################################################################
# Transformers included in sugar
################################################################################

################ a macro for tail recursion ##############
# TODO: give a name to this kind of macros, and maybe provide
# a function to 'encapsulate' the common part of this
# kind of macros involving the redefinition of proc.
proc sugar::tailrecproc {name arglist body} {
    # Convert the script into a Tcl list
    set l [sugar::scriptToList $body]
    # Convert tail calls
    set l [sugar::tailrec_convert_calls $name $arglist $l]
    # Add the final break
    lappend l [list {TOK break} {EOL "\n"}]
    # Convert it back to script
    set body [sugar::listToScript $l]
    # Add the surrounding while 1
    set body "while 1 {$body}"
    # Call [proc]
    uplevel ::proc [list $name $arglist $body]
}

# Convert tail calls. Helper for tailrec_proc.
# Recursively call itself on [if] script arguments.
proc sugar::tailrec_convert_calls {name arglist code} {
    # Search the last non-null command.
    set lastidx -1
    for {set j 0} {$j < [llength $code]} {incr j} {
	set cmd [lindex $code $j]
	if {[sugar::indexbytype $cmd TOK 0] != -1} {
	    set lastidx $j
	    set cmdidx [sugar::indexbytype $cmd TOK 0]
	}
    }
    if {$lastidx == -1} {
	return $code
    }
    set cmd [lindex $code $lastidx]
    set cmdname [lindex $cmd $cmdidx 1]
    if {[lindex $cmd 0 0] eq {SPACE}} {
	set space [lindex $cmd 0 1]
    } else {
	set space " "
    }
    if {$cmdname eq $name} {
	#puts "TAILCALL -> $cmdname"
	set recargs [lrange [sugar::tokens $cmd] 1 end]
	set t [list [list SPACE $space] [list TOK foreach] [list SPACE " "]]
	lappend t [list TOK "\[list "]
	foreach a $arglist {
	    lappend t [list TOK $a] [list SPACE " "]
	}
	lappend t [list TOK "\] "]
	lappend t [list TOK "\[list "]
	foreach a $recargs {
	    lappend t [list TOK $a] [list SPACE " "]
	}
	lappend t [list TOK "\] "]
	lappend t [list TOK break] [list EOL "\n"]
	set code [linsert $code $lastidx $t]
	incr lastidx
	lset code $lastidx [list [list SPACE $space] [list TOK continue] [list EOL "\n"]]
    } elseif {$cmdname eq {if}} {
	#puts "IF CALL"
	for {set j 0} {$j < [llength $cmd]} {incr j} {
	    if {[lindex $cmd $j 0] ne {TOK}} continue 
	    switch -- [lindex $cmd $j 1] {
		if - elseif {
		    incr j 2
		}
		else {
		    incr j 1
		}
		default {
		    set script [lindex $code $lastidx $j 1]
		    #puts "$j -> $script"
		    set scriptcode [sugar::scriptToList [lindex $script 0]]
		    set converted [sugar::tailrec_convert_calls $name $arglist $scriptcode]
		    lset code $lastidx $j 1 [list [sugar::listToScript $converted]]
		}
	    }
	}
    }
    return $code
}
sugar-0.1.tm {F 20898 20898} cflib-1.2.tm {F 16002 36900} rpm-0.1.tm {F 4606 41506}tcl {D 83 83}#!/usr/bin/env cfkit8.6

# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4

set dir	[pwd]

package require cflib
package require platform
package require rpm

namespace eval cflib {
	namespace export *
}
namespace import cflib::*

proc fail {msg} { #<<<
	puts stderr $msg
	exit 1
}

#>>>
proc getkey {dict key args} { #<<<
	if {[llength $args] > 1} {
		throw {syntax} "Too many arguments, expecting dict key ?default?"
	}
	if {[dict exists $dict $key]} {
		return [dict get $dict $key]
	}
	if {[llength $args] == 1} {
		return [lindex $args 0]
	}
	set choices	[join [dict keys $dict] "\", \""]
	throw [list invalid_key $key] "Invalid key: \"$key\", choose from \"$choices\""
}

#>>>
proc decomment {in} { #<<<
	set out	""

	foreach line [split $in \n] {
		if {[string index [string trim $line] 0] eq "#"} continue
		append out	$line "\n"
	}

	return $out
}

#>>>
proc dsl_eval {interp dsl_commands dsl_script args} { #<<<
	set aliases_old	{}
	foreach {cmdname cmdargs cmdbody} [decomment $dsl_commands] {
		dict set aliases_old $cmdname [$interp alias $cmdname]

		$interp alias $cmdname apply [list $cmdargs $cmdbody] {*}$args
	}

	try {
		$interp eval $dsl_script
	} finally {
		dict for {cmdname oldalias} $aliases_old {
			$interp alias $cmdname $oldalias
		}
	}
}

#>>>

# Build tbuildconf <<<
set tbuildconf [dict create \
	projfile			tbuild.proj \
	tm_build			tm \
	repo_base			[file join $::env(HOME) .tbuild repo] \
	default_runtime		kbskit* \
	default_platform	linux-glibc2.3-ix86 \
]

foreach file [list \
		[file join / etc tbuild.conf] \
		[file join $env(HOME) .tbuild config] \
		[file join $dir .tbuild config] \
] {
	if {[file exists $file] && [file   readable $file]} {
		set tbuildconf	[dict merge $tbuildconf [readfile $file]]
	}
}
# Build tbuildconf >>>

oo::object create actions
oo::objdefine actions {
	method build {name args} { #<<<
		global projinfo
		my _load_projfile

		if {$name eq "all"} {
			set targets {}

			foreach {category target} [my _targets] {
				my build $target {*}$args
			}
			return
		}

		set istm	[dict exists $projinfo tms $name]
		set ispkg	[dict exists $projinfo pkgs $name]
		set isapp	[dict exists $projinfo applications $name]

		if {!($istm || $ispkg || $isapp)} {
			fail "Target \"$name\" is not a tm, package or application"
		}

		if {$istm} {
			my _build_tm $name {*}$args
		}
		
		if {$ispkg} {
			puts "would build pkg \"$name\""
		}

		if {$isapp} {
			my _build_application $name {*}$args
		}
	}

	#>>>
	method _build_tm {name args} { #<<<
		global projinfo
		my _load_projfile

		dict with projinfo tms $name {}

		set tm_data	""

		append tm_data	[list package provide $name $version] "\n"

		if {[info exists requires]} {
			foreach req $requires {
				append tm_data [list package require {*}$req] "\n"
			}
		}

		if {[info exists init]} {
			append tm_data $init "\n"
		}

		foreach file $files {
			set file_data	[readfile $file]
			append tm_data $file_data
			if {[string index $file_data end] ne "\n"} {
				append tm_data "\n"
			}
		}

		set out_fn_base	[dict get $::tbuildconf tm_build]

		set target_platforms	[dict keys $platforms]
		if {[llength $target_platforms] == 0} {
			fail "No platforms specified"
		}

		foreach platform $target_platforms {
			set tm_name		${name}-$version.tm
			set out_fn_dir	[file dirname [file join $out_fn_base $platform $tm_name]]
			set out_fn	[file join $out_fn_dir [file tail ${name}-$version.tm]]

			if {![file exists $out_fn_dir]} {
				file mkdir $out_fn_dir
			}
			if {"-compress" in $args} {
				set oldsize	[string length $tm_data]
				set compressed [string map [list "\u001a" "\\u001a"] [zlib deflate $tm_data 3]]
				set tm_data	[list eval zlib inflate $compressed]
				set newsize	[string length $tm_data]
				puts "Compressed $tm_name $oldsize -> $newsize"
			}
			writefile $out_fn $tm_data
			puts "Wrote \"$out_fn\""
		}
	}

	#>>>
	method _build_application {name args} { #<<<
		global projinfo
		my _load_projfile

		set appsettings	[dict get $projinfo applications $name]

		dict for {platform platformsettings} [dict get $appsettings platforms] {
			set before	[pwd]
			my _in_tmp_dir {
				file mkdir $name.vfs

				# main.tcl <<<
				set tokens	[dict create]
				if {[dict exists $appsettings choose_package]} {
					dict set tokens %choose_package% \
							[list [dict get $appsettings choose_package]]
				} else {
					dict set tokens %choose_package% [list [list return $name]]
				}

				set main.tcl_data [string map $tokens {
if {[catch {
	package require starkit
}]} {
	set have_starkit	0
} else {
	set have_starkit	1
}
package require platform

apply {
	{} {
		set here	[file dirname [info script]]
		foreach platform [platform::patterns [platform::identify]] {
			set pkgpath	[file join $here pkg $platform]
			set tmpath	[file join $here tm $platform]
			if {[file exists $pkgpath] && [file isdirectory $pkgpath]} {
				lappend ::auto_path $pkgpath
			}
			if {[file exists $tmpath] && [file isdirectory $tmpath]} {
				::tcl::tm::path add $tmpath
			}
		}
	}
}

if {$have_starkit && [starkit::startup] eq "sourced"} return

try {
	package require app-[apply {{argv} %choose_package%} $argv]
} on error {errmsg options} {
	puts stderr "$errmsg\n[dict get $options -errorinfo]"
}
}]

				writefile [file join $name.vfs main.tcl] [set main.tcl_data]
				# main.tcl >>>

				set app_base	[file join $name.vfs pkg tcl app-$name]
				file mkdir $app_base

				# _init.tcl <<<
				if {[dict exists $appsettings entrypoint]} {
					set entrypoint	[dict get $appsettings entrypoint]
				} else {
					set entrypoint	[lindex [dict get $appsettings files] 0]
				}
				if {$entrypoint ni [dict get $appsettings files]} {
					error "Invalid file specified as entrypoint: \"$entrypoint\""
				}

				set _init.tcl_data		{}
				set include_packages	{}
				foreach req [dict get $appsettings requires] {
					lappend _init.tcl_data	[list package require {*}$req]
					lappend include_packages $req
				}
				if {[dict exists $platformsettings requires]} {
					foreach req [dict get $platformsettings requires] {
						puts stderr "Adding specific platform require: ($req) for $platform"
						lappend _init.tcl_data	[list package require {*}$req]
						lappend include_packages $req
					}
				}
				lappend _init.tcl_data [list package provide app-$name [dict get $appsettings version]]
				lappend _init.tcl_data "source \[file join \[file dirname \[info script\]\] [list $entrypoint]]"

				writefile [file join $app_base _init.tcl] \
						[join [set _init.tcl_data] "\n"]
				# _init.tcl >>>

				# app pkgIndex.tcl <<<
				set pkgIndex.tcl_data	[string map [dict create \
						%name%		[list app-$name] \
						%version%	[list [dict get $appsettings version]] \
				] {package ifneeded %name% %version% [list source [file join $dir _init.tcl]]
				}]

				writefile [file join $app_base pkgIndex.tcl] [set pkgIndex.tcl_data]
				# app pkgIndex.tcl >>>

				# Copy specified application files <<<
				foreach file [dict get $appsettings files] {
					set src_fn	[file join $before $file]
					if {![file exists $src_fn]} {
						error "Specified file doesn't exist: \"$file\""
					}
					if {![file readable $src_fn]} {
						error "Specified file isn't readable: \"$file\""
					}
					set parts	[file split $file]
					if {[lindex $parts 0] eq "/"} {
						error "Absolute paths not allowed for files: \"$file\""
					}
					if {".." in $parts} {
						error "Cannot have \"..\" in file specification: \"$file\""
					}
					set file_dest	[file join $app_base $file]
					set file_dir	[file dirname $file_dest]
					if {![file exists $file_dir]} {
						file mkdir $file_dir
					}
					set file_contents	[readfile $src_fn binary]
					writefile $file_dest $file_contents binary
				}
				# Copy specified application files >>>

				if {[dict exists $appsettings runtime]} {
					set runtime		[dict get $appsettings runtime]
				} else {
					set runtime		[dict get $::tbuildconf default_runtime]
				}

				if {$platform eq "tcl"} {
					set runtime_platform	[dict get $::tbuildconf default_platform]
				} else {
					set runtime_platform	$platform
				}

				lassign [my _select_runtime $runtime $runtime_platform] \
						runtime_name \
						runtime_version \
						runtime_path \
						runtime_info

				set ::package_manifest [dict get $runtime_info builtin_packages]

				set compatible_platforms	[platform::patterns $platform]
				dict for {fn data} [my _resolve_packages $include_packages $compatible_platforms] {
					puts stderr "transcribing file ($fn)"
					set fqfn	[file join $name.vfs $fn]
					set dir		[file dirname $fqfn]
					if {![file exists $dir]} {
						file mkdir $dir
					}
					writefile $fqfn $data binary
				}

				unset ::package_manifest

				set out_app_base	[file join [dict get $::tbuildconf repo_base] apps $platform]
				if {![file exists $out_app_base]} {
					file mkdir $out_app_base
				}
				set app_name		[file join $out_app_base $name]
				set app_name_static	[file join $out_app_base ${name}-static]
				if {"starkit" in [dict get $runtime_info builtin_packages]} {
					puts "Writing application \"$app_name\""
					exec -- sdx wrap $app_name -vfs $name.vfs -interp [file tail $runtime_path]
					if {$platform ne "tcl"} {
						puts "Writing application \"$app_name_static\""
						exec -- sdx wrap $app_name_static -vfs $name.vfs -runtime $runtime_path
					}
				} elseif {"trofs" in [dict get $runtime_info builtin_packages]} {
					package require trofs

					set header	""
					append header	"#!/bin/sh\n"
					append header	"# \\\n"
					append header	[string map [list %r $runtime_name] {exec "%r" "$0" ${1+"$@"}}] "\n"
					append header \
{
package require trofs
set top		[trofs::mount [info script]]
set main	[file join $top main.tcl]
if {![file exists $main]} {
	puts stderr "No main.tcl"
	exit 1
}
source $main
}
					cflib::writefile $app_name $header
					trofs::archive $name.vfs $app_name

					if {$::tcl_platform(platform) eq "unix"} {
						file attributes $app_name -permissions rwxr-xr-x
					}

					if {$platform ne "tcl"} {
						# TODO: merge $name.vfs with boot trofs
					}
				}
			}
		}

		if {[dict exists $platformsettings rpm]} {
			if {[info exists rpm]} {unset rpm}
			dict set platformsettings rpm name $name
			if {![dict exists $platformsettings rpm version]} {
				dict set platformsettings rpm version [dict get $appsettings version]
			}
			if {![dict exists $appsettings summary]} {
				error "Require summary to be defined to build an rpm"
			}
			if {![dict exists $appsettings description]} {
				error "Require description to be defined to build an rpm"
			}
			dict set platformsettings rpm summary [dict get $appsettings summary]
			dict set platformsettings rpm description [dict get $appsettings description]
			set reqs	[dict get $platformsettings rpm requires]
			switch -glob -- $runtime {
				"*cfkit*" {
					lappend reqs	"cfkit"
				}

				"*kbskit*" {
					lappend reqs	"kbskit"
				}
			}
			dict set platformsettings rpm requires [lsort -unique $reqs]
			array set rpm [dict get $platformsettings rpm]
			puts "rpm settings:"
			parray rpm
			unset rpm
			set files	[list $app_name [file join / usr bin [file tail $app_name]]]
			if {[dict exists $platformsettings rpm files]} {
				lappend files {*}[dict get $platformsettings rpm files]
			}
			puts "files:\n[join $files \n]"
			rpm::make_rpm [dict get $platformsettings rpm] $files [dict get $platformsettings rpm target]
		}
	}

	#>>>
	method _select_runtime {runtime platform} { #<<<
		set candidates	{}
		foreach compatplat [platform::patterns $platform] {
			set runtime_base	[file join [dict get $::tbuildconf repo_base] runtimes $compatplat]
			foreach candidate [glob -nocomplain -type f [file join $runtime_base info *]] {
				set info	[readfile $candidate]
				set simplename	[file tail $candidate]
				if {[string match $runtime $simplename]} {
					lappend candidates [list \
							[file tail $candidate] \
							[dict get $info builtin_packages Tcl] \
							[file join $runtime_base bin $simplename] \
							$info \
					]
				}
			}
		}

		if {[llength $candidates] == 0} {
			error "No suitable runtime found matching \"$runtime\" for platform \"$platform\""
		}

		set ordered	[lsort \
				-index 1 \
				-decreasing \
				-command [list package vcompare] \
				$candidates]

		return [lindex $ordered 0]
	}

	#>>>
	method _resolve_packages {required compatible_platforms} { #<<<
		set file_list	[dict create]
		foreach req $required {
			puts stderr "Resolving requirement: ($req)"
			set rest	[lassign $req pkgname]
			if {
				[dict exists $::package_manifest $pkgname] &&
				([llength $rest] == 0 ||
				[package vsatisfies [dict get $::package_manifest $pkgname] {*}$rest])
			} continue

			set available	[my _find_compatible $req $compatible_platforms]
			try {
				foreach candidate $available {
					lassign $candidate ver type path

					if {$type eq "tm"} { #<<<
						set sub_requires	[my _extract_tm_requires $path]
						set sub_file_list	[my _resolve_packages $sub_requires $compatible_platforms]
						set file_list	[dict merge \
								$file_list \
								$sub_file_list \
						]
						set path_rel	[my _strip_base [dict get $::tbuildconf repo_base] $path]

						dict set file_list $path_rel [readfile $path binary]
						dict set ::package_manifest $pkgname $ver
						throw {found} ""
						#>>>
					} elseif {$type eq "pkg"} { #<<<
						foreach file [my _list_files_recursive $path] {
							puts "Addling file ($file)"
							set file_rel	[my _strip_base [dict get $::tbuildconf repo_base] $file]
							dict set file_list $file_rel [readfile $file binary]
						}
						dict set ::package_manifest $pkgname $ver
						throw {found} ""
						#>>>
					} else { #<<<
						error "Cannot deal with package type: \"$type\""
						#>>>
					}
				}
				throw {not_found} ""
			} trap {found} {} {
				continue
			} trap {not_found} {} {
				error "No suitable candidates found for requirement \"$req\""
			}
		}

		return $file_list
	}

	#>>>
	method _strip_base {base path} { #<<<
		set fqfn_base	[fullynormalize $base]
		set fqfn_path	[fullynormalize $path]
		set baselen	[string length $fqfn_base]
		set prefix	[string range $fqfn_path 0 $baselen-1]
		if {$prefix ne $fqfn_base} {
			puts "fqfn_base: ($fqfn_base)"
			puts "fqfn_path: ($fqfn_path)"
			error "\"$path\" isn't contained in \"$base\""
		}
		string range $fqfn_path $baselen+1 end
	}

	#>>>
	method _extract_tm_requires {path} { #<<<
		set requires	{}
		package require sugar
		foreach cmdraw [sugar::scriptToList [readfile $path]] {
			set cmd	{}
			foreach token $cmdraw {
				lassign $token type val

				if {$type eq "TOK"} {
					lappend cmd $val
				}
			}

			if {[lrange $cmd 0 1] eq [list package require]} {
				set rest	[lassign [lrange $cmd 2 end] name]
				puts stderr "detected requirement for \"$name\" \"$rest\" from \"$path\""
				lappend requires	[lrange $cmd 2 end]
			}
		}

		return $requires
	}

	#>>>
	method _list_files_recursive {base} { #<<<
		# TODO: defend against circular links
		set entries	{}

		foreach ent [glob -type f -nocomplain [file join $base *]] {
			lappend entries $ent
		}

		foreach ent [glob -type d -nocomplain [file join $base *]] {
			lappend entries {*}[my _list_files_recursive $ent]
		}

		return $entries
	}

	#>>>
	method _find_compatible {req compatible_platforms} { #<<<
		set available	{}

		set rest	[lassign $req pkgname]
		set pkgpath	[string map [list :: /] $pkgname]
		set tm_pkg		[file tail $pkgpath]
		set tm_prefix	[file dirname $pkgpath]

		set repo_base	[dict get $::tbuildconf repo_base]

		# Look for tm
		foreach plat $compatible_platforms {
			if {$tm_prefix ne "."} {
				set tm_path		[file join $repo_base tm $plat $tm_prefix]
			} else {
				set tm_path		[file join $repo_base tm $plat]
			}
			foreach match [glob -nocomplain -type f [file join $tm_path $tm_pkg-*.tm]] {
				if {![regexp {^([[:alpha:]][:[:alnum:]]*)-([[:digit:]].*)\.tm$} [file tail $match] -> name version]} continue
				if {
					[llength $rest] == 0 ||
					[package vsatisfies $version {*}$rest]
				} {
					lappend available [list $version tm $match]
				}
			}
		}

		# Look for package
		foreach plat $compatible_platforms {
			set pkg_path		[file join $repo_base pkg $plat]
			foreach pkgIndex [glob -nocomplain -type f [file join $pkg_path * pkgIndex.tcl]] {
				package require sugar
				foreach cmdraw [sugar::scriptToList [readfile $pkgIndex]] {
					set cmd	{}
					foreach token $cmdraw {
						lassign $token type val
						if {$type eq "TOK"} {
							lappend cmd $val
						}
					}

					if {[lrange $cmd 0 2] eq [list package ifneeded $pkgname]} {
						set offered_version	[lindex $cmd 3]
						if {
							[llength $rest] == 0 ||
							[package vsatisfies $offered_version {*}$rest]
						} {
							lappend available	[list $offered_version pkg [file dirname $pkgIndex]]
						}
					}
				}
			}
		}

		return [lsort -unique -decreasing -command [list apply {
			{a b} {
				set aver	[lindex $a 0]
				set bver	[lindex $b 0]
				set sort	[package vcompare $aver $bver]
				if {$sort == 0} {
					# As a version tie-breaker, prefer tm over pkg
					set atype	[lindex $a 1]
					set btype	[lindex $b 1]
					if {$atype eq $btype} {
						return 0
					} elseif {$atype eq "tm" && $btype ne "tm"} {
						return 1
					} elseif {$atype ne "tm" && $btype eq "tm"} {
						return -1
					}
				}
				return $sort
			}
		}] $available]
	}

	#>>>
	method _refresh_build {name} { #<<<
		# TODO: determine if target $name needs to be rebuilt
		my build $name
	}

	#>>>
	method clean {} { #<<<
	}

	#>>>
	method install {args} { #<<<
		global projinfo
		my _load_projfile

		if {[llength $args] == 0 || "all" in $args} {
			foreach {category target} [my _targets] {
				my _install_$category $target
			}
			return
		}

		foreach name $args {
			set istm	[dict exists $projinfo tms $name]
			set ispkg	[dict exists $projinfo pkgs $name]
			set isapp	[dict exists $projinfo applications $name]

			if {!($istm || $ispkg || $isapp)} {
				fail "No target called \"$name\""
			}

			if {$istm} {my _install_tm $name}
			if {$ispkg} {my _install_pkg $name}
			if {$isapp} {my _install_app $name}
		}
	}

	#>>>
	method _install_tm {name} { #<<<
		global projinfo

		my _refresh_build $name
		dict with projinfo tms $name {
			set src_fn_base	[dict get $::tbuildconf tm_build]
			set dst_fn_base	[file join [dict get $::tbuildconf repo_base] tm]

			set target_platforms	[dict keys $platforms]
			if {[llength $target_platforms] == 0} {
				fail "No platforms specified"
			}

			foreach platform $target_platforms {
				set tm_name	${name}-$version.tm
				set src_fn	[file join \
						$src_fn_base \
						$platform \
						$tm_name \
				]
				if {![file exists $src_fn]} {
					puts stderr "WARNING: Expecting \"$src_fn\" but it wasn't built"
					continue
				}

				set dst_fn_dir	[file dirname [file join $dst_fn_base $platform $tm_name]]
				if {![file exists $dst_fn_dir]} {
					file mkdir $dst_fn_dir
				}

				try {
					file copy -force $src_fn $dst_fn_dir
					puts "Installed tm $name in $dst_fn_dir"
				} on error {errmsg options} {
					fail "Error installing tm $name: $errmsg"
				}
			}
		}
	}

	#>>>
	method _install_pkg {name} { #<<<
		global projinfo

		dict with $projinfo 
	}

	#>>>
	method _install_app {name} { #<<<
	}

	#>>>
	method remove {} { #<<<
	}

	#>>>
	method path {args} { #<<<
		set paths		{}

		# Apps
		set basepath	[file join [dict get $::tbuildconf repo_base] apps]
		foreach platform [platform::patterns [platform::identify]] {
			# TODO: figure out how to quote spaces and other nasties
			set path		[file join $basepath $platform]
			if {"-all" in $args || [file isdirectory $path]} {
				lappend paths	[file nativename $path]
			}
		}

		# Runtimes
		set basepath	[file join [dict get $::tbuildconf repo_base] runtimes]
		foreach platform [platform::patterns [platform::identify]] {
			# TODO: figure out how to quote spaces and other nasties
			set path		[file join $basepath $platform bin]
			if {"-all" in $args || [file isdirectory $path]} {
				lappend paths	[file nativename $path]
			}
		}

		puts [join $paths :]
	}

	#>>>
	method _load_projfile {} { #<<<
		global projinfo projinfo_loaded

		if {[info exists projinfo_loaded]} return

		set projfile	[getkey $::tbuildconf projfile]
		set conffile	[file join $::dir $projfile]

		if {![file exists $conffile]} {
			fail "Cannot find config file $projfile"
		}

		if {![file readable $conffile]} {
			fail "Cannot read config file $projfile"
		}

		set projinfo {
			tms		{}
			pkgs	{}
		}

		interp create -safe proj

		# TODO: Not safe - provide filtered versions of these
		interp expose proj file
		interp expose proj glob

		dsl_eval proj {
			tm {name script} { #<<<
				global projinfo

				dict set projinfo tms $name {
					platforms	{}
				}

				dsl_eval proj {
					version {cx ver} { #<<<
						dict set ::projinfo {*}$cx version $ver
					}

					#>>>
					summary {cx summary} { #<<<
						dict set ::projinfo {*}$cx summary $summary
					}

					#>>>
					description {cx desc} { #<<<
						dict set ::projinfo {*}$cx description $desc
					}

					#>>>
					requires {cx packagelist} { #<<<
						dict set ::projinfo {*}$cx requires $packagelist
					}

					#>>>
					init {cx script} { #<<<
						dict set ::projinfo {*}$cx init $script
					}

					#>>>
					files {cx filelist} { #<<<
						set resolvedfiles	{}
						foreach pattern $filelist {
							foreach file [glob -nocomplain -type file $pattern] {
								set fqfn	[fullynormalize $file]
								if {$fqfn ni $resolvedfiles} {
									lappend resolvedfiles $fqfn
								}
							}
						}
						dict set ::projinfo {*}$cx files $resolvedfiles
					}

					#>>>
					cfiles {cx filelist} { #<<<
						dict set ::projinfo {*}$cx cfiles $filelist
					}

					#>>>
					platform {cx platname {platform_specific_config {}}} { #<<<
						dict set ::projinfo {*}$cx platforms $platname [dict create]
						dsl_eval proj {
							requires {cx packagelist} { #<<<
								dict set ::projinfo {*}$cx requires $packagelist
							}

							#>>>
						} $platform_specific_config [concat $cx [list platforms $platname]]
					}

					#>>>
				} $script [list tms $name]
			}

			#>>>
			application {name script} { #<<<
				global projinfo

				dict set projinfo applications $name {
					platforms	{}
				}

				dsl_eval proj {
					runtime {cx runtime} { #<<<
						dict set ::projinfo {*}$cx runtime $runtime
					}

					#>>>
					version {cx ver} { #<<<
						dict set ::projinfo {*}$cx version $ver
					}

					#>>>
					version_of {pkg} { #<<<
						# TODO: find version of package $pkg
					}

					#>>>
					summary {cx summary} { #<<<
						dict set ::projinfo {*}$cx summary $summary
					}

					#>>>
					description {cx desc} { #<<<
						set trimmed	{}
						foreach line [string trim [split $desc \n]] {
							lappend trimmed	[string trim $line]
						}
						dict set ::projinfo {*}$cx description [join $trimmed \n]
					}

					#>>>
					requires {cx packagelist} { #<<<
						dict set ::projinfo {*}$cx requires $packagelist
					}

					#>>>
					init {cx script} { #<<<
						dict set ::projinfo {*}$cx init $script
					}

					#>>>
					files {cx filelist} { #<<<
						set resolvedfiles	{}
						foreach pattern $filelist {
							foreach file [glob -nocomplain -type file $pattern] {
								set fqfn	[fullynormalize $file]
								if {$fqfn ni $resolvedfiles} {
									#lappend resolvedfiles $fqfn
									lappend resolvedfiles $file
								}
							}
						}
						dict set ::projinfo {*}$cx files $resolvedfiles
					}

					#>>>
					cfiles {cx filelist} { #<<<
						dict set ::projinfo {*}$cx cfiles $filelist
					}

					#>>>
					platform {cx platname {platform_specific_config {}}} { #<<<
						dict set ::projinfo {*}$cx platforms $platname [dict create]
						dsl_eval proj {
							rpm {cx settings} { #<<<
								dict set ::projinfo {*}$cx rpm {
									target			""
									release			1
									license			"commercial"
									vendor			"Codeforge"
									group			"Applications/System"
									sourcetar		"tbuild_tmp_source.tar.gz"
									requires		{}
									post_scriptlet	""
									preun_scriptlet	""
								}
								dsl_eval proj {
									target {cx target} { #<<<
										dict set ::projinfo {*}$cx target $target
									}

									#>>>
									release {cx rel} { #<<<
										dict set ::projinfo {*}$cx release $rel
									}

									#>>>
									license {cx lic} { #<<<
										dict set ::projinfo {*}$cx license $lic
									}

									#>>>
									vendor {cx vendor} { #<<<
										dict set ::projinfo {*}$cx vendor $vendor
									}

									#>>>
									group {cx group} { #<<<
										dict set ::projinfo {*}$cx group $group
									}

									#>>>
									rpmrequires {cx req} { #<<<
										dict set ::projinfo {*}$cx requires $req
									}

									#>>>
									post_scriptlet {cx scr} { #<<<
										dict set ::projinfo {*}$cx post_scriptlet $scr
									}

									#>>>
									preun_scriptlet {cx scr} { #<<<
										dict set ::projinfo {*}$cx preun_scriptlet $scr
									}

									#>>>
									files {cx files} { #<<<
										dict set ::projinfo {*}$cx files $files
									}

									#>>>
								} $settings [concat $cx [list rpm]]
							}

							#>>>
							requires {cx packagelist} { #<<<
								dict set ::projinfo {*}$cx requires $packagelist
							}

							#>>>
						} $platform_specific_config [concat $cx [list platforms $platname]]
					}

					#>>>
					choose_package {cx script} { #<<<
						dict set ::projinfo {*}$cx choose_package $script
					}

					#>>>
				} $script [list applications $name]
			}

			#>>>
			pkg {name script} { #<<<
				global projinfo

				dict set projinfo pkgs $name {
					platforms	{}
				}

				dsl_eval proj {
					version {cx ver} { #<<<
						dict set ::projinfo {*}$cx version $ver
					}

					#>>>
					summary {cx summary} { #<<<
						dict set ::projinfo {*}$cx summary $summary
					}

					#>>>
					description {cx desc} { #<<<
						dict set ::projinfo {*}$cx description $desc
					}

					#>>>
					requires {cx packagelist} { #<<<
						dict set ::projinfo {*}$cx requires $packagelist
					}

					#>>>
					init {cx script} { #<<<
						dict set ::projinfo {*}$cx init $script
					}

					#>>>
					files {cx filelist} { #<<<
						dict set ::projinfo {*}$cx files $filelist
					}

					#>>>
					cfiles {cx filelist} { #<<<
						dict set ::projinfo {*}$cx cfiles $filelist
					}

					#>>>
					platform {cx platname {platform_specific_config {}}} { #<<<
						dict set ::projinfo {*}$cx platforms $platname [dict create]
						dsl_eval proj {
							requires {cx packagelist} { #<<<
								dict set ::projinfo {*}$cx requires $packagelist
							}

							#>>>
						} $platform_specific_config [concat $cx [list platforms $platname]]
					}

					#>>>
				} $script [list pkgs $name]
			}

			#>>>
			this_platform {} { #<<<
				return [platform::identify]
			}

			#>>>
		} [readfile $conffile]

		interp delete proj

		set projinfo_loaded	1
	}

	#>>>
	method _targets {} { #<<<
		global projinfo
		my _load_projfile

		set targets	{}

		set catmap	{
			tms				tm
			pkgs			pkg
			applications	apps
		}

		foreach category {tms pkgs applications} {
			if {[dict exists $projinfo $category]} {
				foreach target [dict keys [dict get $projinfo $category]] {
					set cat	[dict get $catmap $category]
					lappend targets [list $cat $target]
				}
			}
		}

		return [concat {*}[lsort -unique $targets]]
	}

	#>>>
	method import_runtime {path platform} { #<<<
		package require platform

		if {![file exists $path]} {
			puts stderr "Invalid path: \"$path\""
			exit 1
		}

		# Special case: win32 runtime on a linux host that can run it with
		# wine (works - how to accomodate it?)
		if {$platform ni [platform::patterns [platform::identify]]} {
			puts stderr "Runtime is incompatible with this platform, please import it on a compatible platform and copy the imported version here"
			exit 1
		}

		# runtime is compatible with the platform we're running on, interrogate it

		lassign [chan pipe] readpipe writepipe

		set handle	[open [list |$path >@ $writepipe] w]
		close $writepipe
		chan configure $handle -blocking 0
		puts -nonewline $handle {
			catch {package require __no_such_package}
			set runtime_info	{}
			set builtin	{}
			foreach package [package names] {
				if {[catch {
					package require $package
				} res]} {
					set errmsg	$res
					puts stderr "Couldn't load package: \"$package\": $errmsg"
				} else {
					set ver	$res
					lappend builtin $package $ver
				}
			}
			lappend runtime_info builtin_packages $builtin
			puts -nonewline $runtime_info
			exit 0
		}
		chan configure $handle -blocking 1
		try {
			chan close $handle
		} trap {CHILDSTATUS} {errmsg options} {
			set exitstatus	[lindex [dict get $options -errorcode] 2]
			puts stderr "Interrogation failed ($exitstatus): $errmsg"
			exit 1
		} on ok {} {
			set output	[read $readpipe]
		} on error {errmsg options} {
			puts "WARNING: interrogation wrote to stderr:\n$errmsg"
			set output	[read $readpipe]
		} finally {
			chan close $readpipe
		}

		try {
			if {![dict exists $output builtin_packages]} {
				error ""
			}
		} on error {} {
			puts stderr "Could not parse interrogation result:\n$output"
			exit 1
		}

		set runtime_base	[file join \
				[dict get $::tbuildconf repo_base] \
				runtimes \
				$platform]
		set runtime_data	[readfile $path binary]
		set runtime_outfn	[file join $runtime_base bin [file tail $path]]
		set info_outfn		[file join $runtime_base info [file tail $path]]

		if {![file exists [file join $runtime_base bin]]} {
			file mkdir [file join $runtime_base bin]
		}
		if {![file exists [file join $runtime_base info]]} {
			file mkdir [file join $runtime_base info]
		}

		set attribs	[file attributes $path]
		writefile $runtime_outfn $runtime_data binary
		file attributes $runtime_outfn {*}$attribs
		writefile $info_outfn $output binary
		puts "Imported runtime \"$path\""
		exit 0
	}

	#>>>
	method _in_tmp_dir {script} { #<<<
		set oldpwd		[pwd]
		set tempfp	[file tempfile tmpdir]
		close $tempfp
		file delete $tmpdir
		file mkdir $tmpdir
		cd $tmpdir
		try {
			uplevel $script
		} on error {errmsg options} {
			dict incr options -level
			return -options $options $errmsg
		} finally {
			cd $oldpwd
			if {[info exists tmpdir] && [file exists $tmpdir]} {
				# TODO: paranoid checks
				file delete -force -- $tmpdir
			}
		}
	}

	#>>>
}

if {[llength $argv] == 0} {
	fail "No action specified"
}

set actionargs	[lassign $argv action]
actions $action {*}$actionargs

package ifneeded app-tbuild 0.2 [list source [file join $dir _init.tcl]]
				package require cflib
package require trofs
package require sugar
package require platform
package require rpm
package provide app-tbuild 0.2
source [file join [file dirname [info script]] tbuild.tcl]_init.tcl {F 200 200} tbuild.tcl {F 30686 30963} pkgIndex.tcl {F 77 277}app-tbuild {D 72 72}tcl {D 20 20}tm {D 13 31081} pkg {D 13 13} main.tcl {F 757 73427}trofs01   4